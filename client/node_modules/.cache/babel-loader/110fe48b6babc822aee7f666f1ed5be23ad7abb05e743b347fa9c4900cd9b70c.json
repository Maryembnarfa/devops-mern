{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Axis as AxisComponent } from '@antv/component';\nimport { Linear as LinearScale } from '@antv/scale';\nimport { deepMix, omit, upperFirst } from '@antv/util';\nimport { extent } from '@antv/vendor/d3-array';\nimport { format } from '@antv/vendor/d3-format';\nimport { angleOf, isFisheye, isParallel, isPolar, isRadial, isTheta, isTranspose, radiusOf } from '../utils/coordinate';\nimport { prettyNumber } from '../utils/number';\nimport { capitalizeFirst } from '../utils/helper';\nimport { adaptor, isVertical, titleContent } from './utils';\nexport function rotateAxis(axis, options) {\n  const {\n    eulerAngles,\n    origin\n  } = options;\n  if (origin) {\n    axis.setOrigin(origin);\n  }\n  if (eulerAngles) {\n    axis.rotate(eulerAngles[0], eulerAngles[1], eulerAngles[2]);\n  }\n}\nfunction sizeOf(coordinate) {\n  // @ts-ignore\n  const {\n    innerWidth,\n    innerHeight,\n    depth\n  } = coordinate.getOptions();\n  return [innerWidth, innerHeight, depth];\n}\nfunction createFisheye(position, coordinate) {\n  const {\n    width,\n    height\n  } = coordinate.getOptions();\n  return tick => {\n    if (!isFisheye(coordinate)) return tick;\n    const tickPoint = position === 'bottom' ? [tick, 1] : [0, tick];\n    const vector = coordinate.map(tickPoint);\n    if (position === 'bottom') {\n      const v = vector[0];\n      const x = new LinearScale({\n        domain: [0, width],\n        range: [0, 1]\n      });\n      return x.map(v);\n    } else if (position === 'left') {\n      const v = vector[1];\n      const x = new LinearScale({\n        domain: [0, height],\n        range: [0, 1]\n      });\n      return x.map(v);\n    }\n    return tick;\n  };\n}\nfunction ticksOf(scale, domain, tickMethod) {\n  if (scale.getTicks) return scale.getTicks();\n  if (!tickMethod) return domain;\n  const [min, max] = extent(domain, d => +d);\n  const {\n    tickCount\n  } = scale.getOptions();\n  return tickMethod(min, max, tickCount);\n}\n// Set inset for axis.\nfunction createInset(position, coordinate) {\n  if (isPolar(coordinate)) return d => d;\n  const options = coordinate.getOptions();\n  const {\n    innerWidth,\n    innerHeight,\n    insetTop,\n    insetBottom,\n    insetLeft,\n    insetRight\n  } = options;\n  const [start, end, size] = position === 'left' || position === 'right' ? [insetTop, insetBottom, innerHeight] : [insetLeft, insetRight, innerWidth];\n  const x = new LinearScale({\n    domain: [0, 1],\n    range: [start / size, 1 - end / size]\n  });\n  return i => x.map(i);\n}\n/**\n * Calc ticks based on scale and coordinate.\n */\nfunction getData(scale, domain, tickCount, defaultTickFormatter, tickFilter, tickMethod, position, coordinate) {\n  var _a;\n  if (tickCount !== undefined || tickMethod !== undefined) {\n    scale.update(Object.assign(Object.assign({}, tickCount && {\n      tickCount\n    }), tickMethod && {\n      tickMethod\n    }));\n  }\n  const ticks = ticksOf(scale, domain, tickMethod);\n  const filteredTicks = tickFilter ? ticks.filter(tickFilter) : ticks;\n  const toString = d => d instanceof Date ? String(d) : typeof d === 'object' && !!d ? d : String(d);\n  const labelFormatter = defaultTickFormatter || ((_a = scale.getFormatter) === null || _a === void 0 ? void 0 : _a.call(scale)) || toString;\n  const applyInset = createInset(position, coordinate);\n  const applyFisheye = createFisheye(position, coordinate);\n  const isHorizontal = position => ['top', 'bottom', 'center', 'outer'].includes(position);\n  const isVertical = position => ['left', 'right'].includes(position);\n  // @todo GUI should consider the overlap problem for the first\n  // and label of arc axis.\n  if (isPolar(coordinate) || isTranspose(coordinate)) {\n    return filteredTicks.map((d, i, array) => {\n      var _a, _b;\n      const offset = ((_a = scale.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scale, d)) / 2 || 0;\n      const tick = applyInset(scale.map(d) + offset);\n      const shouldReverse = isRadial(coordinate) && position === 'center' || isTranspose(coordinate) && ((_b = scale.getTicks) === null || _b === void 0 ? void 0 : _b.call(scale)) && isHorizontal(position) || isTranspose(coordinate) && isVertical(position);\n      return {\n        value: shouldReverse ? 1 - tick : tick,\n        label: toString(labelFormatter(prettyNumber(d), i, array)),\n        id: String(i)\n      };\n    });\n  }\n  return filteredTicks.map((d, i, array) => {\n    var _a;\n    const offset = ((_a = scale.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scale, d)) / 2 || 0;\n    const tick = applyFisheye(applyInset(scale.map(d) + offset));\n    const shouldReverse = isVertical(position);\n    return {\n      value: shouldReverse ? 1 - tick : tick,\n      label: toString(labelFormatter(prettyNumber(d), i, array)),\n      id: String(i)\n    };\n  });\n}\nfunction inferGridLength(position, coordinate) {\n  let plane = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'xy';\n  const [width, height, depth] = sizeOf(coordinate);\n  if (plane === 'xy') {\n    if (position.includes('bottom') || position.includes('top')) return height;\n    return width;\n  } else if (plane === 'xz') {\n    if (position.includes('bottom') || position.includes('top')) return depth;\n    return width;\n  } else {\n    if (position.includes('bottom') || position.includes('top')) return height;\n    return depth;\n  }\n}\nfunction inferLabelOverlap() {\n  let transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let style = arguments.length > 1 ? arguments[1] : undefined;\n  if (transform.length > 0) return transform;\n  const {\n    labelAutoRotate,\n    labelAutoHide,\n    labelAutoEllipsis,\n    labelAutoWrap\n  } = style;\n  const finalTransforms = [];\n  const addToTransforms = (overlap, state) => {\n    if (state) {\n      finalTransforms.push(Object.assign(Object.assign({}, overlap), state));\n    }\n  };\n  addToTransforms({\n    type: 'rotate',\n    optionalAngles: [0, 15, 30, 45, 60, 90]\n  }, labelAutoRotate);\n  addToTransforms({\n    type: 'ellipsis',\n    minLength: 20\n  }, labelAutoEllipsis);\n  addToTransforms({\n    type: 'hide'\n  }, labelAutoHide);\n  addToTransforms({\n    type: 'wrap',\n    wordWrapWidth: 100,\n    maxLines: 3,\n    recoveryWhenFail: true\n  }, labelAutoWrap);\n  return finalTransforms;\n}\nfunction inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = bbox;\n  const center = [x + width / 2, y + height / 2];\n  const radius = Math.min(width, height) / 2;\n  const [startAngle, endAngle] = angleOf(coordinate);\n  const [w, h] = sizeOf(coordinate);\n  const r = Math.min(w, h) / 2;\n  const common = {\n    center,\n    radius,\n    startAngle,\n    endAngle,\n    gridLength: (outerRadius - innerRadius) * r\n  };\n  if (position === 'inner') {\n    // @ts-ignore\n    const {\n      insetLeft,\n      insetTop\n    } = coordinate.getOptions();\n    return Object.assign(Object.assign({}, common), {\n      center: [center[0] - insetLeft, center[1] - insetTop],\n      labelAlign: 'perpendicular',\n      labelDirection: 'positive',\n      tickDirection: 'positive',\n      gridDirection: 'negative'\n    });\n  }\n  // arc outer\n  return Object.assign(Object.assign({}, common), {\n    labelAlign: 'parallel',\n    labelDirection: 'negative',\n    tickDirection: 'negative',\n    gridDirection: 'positive'\n  });\n}\nfunction inferGrid(value, coordinate, scale) {\n  if (isTheta(coordinate) || isParallel(coordinate)) return false;\n  // Display axis grid for non-discrete values.\n  return value === undefined ? !!scale.getTicks : value;\n}\nfunction infer3DAxisLinearOverrideStyle(coordinate) {\n  // @ts-ignore\n  const {\n    depth\n  } = coordinate.getOptions();\n  return depth ? {\n    tickIsBillboard: true,\n    lineIsBillboard: true,\n    labelIsBillboard: true,\n    titleIsBillboard: true,\n    gridIsBillboard: true\n  } : {};\n}\nfunction inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = bbox;\n  if (position === 'bottom') {\n    return {\n      startPos: [x, y],\n      endPos: [x + width, y]\n    };\n  }\n  if (position === 'left') {\n    return {\n      startPos: [x + width, y + height],\n      endPos: [x + width, y]\n    };\n  }\n  if (position === 'right') {\n    return {\n      startPos: [x, y + height],\n      endPos: [x, y]\n    };\n  }\n  if (position === 'top') {\n    return {\n      startPos: [x, y + height],\n      endPos: [x + width, y + height]\n    };\n  }\n  // linear axis, maybe in parallel, polar, radial or radar systems.\n  if (position === 'center') {\n    // axisY\n    if (orientation === 'vertical') {\n      return {\n        startPos: [x, y],\n        endPos: [x, y + height]\n      };\n    }\n    // axisX\n    else if (orientation === 'horizontal') {\n      return {\n        startPos: [x, y],\n        endPos: [x + width, y]\n      };\n    }\n    // axis with rotate\n    else if (typeof orientation === 'number') {\n      const [cx, cy] = coordinate.getCenter();\n      const [innerRadius, outerRadius] = radiusOf(coordinate);\n      const [startAngle, endAngle] = angleOf(coordinate);\n      const r = Math.min(width, height) / 2;\n      // @ts-ignore\n      const {\n        insetLeft,\n        insetTop\n      } = coordinate.getOptions();\n      const innerR = innerRadius * r;\n      const outerR = outerRadius * r;\n      const [actualCx, actualCy] = [cx + x - insetLeft, cy + y - insetTop];\n      const [cos, sin] = [Math.cos(orientation), Math.sin(orientation)];\n      const startPos = [actualCx + outerR * cos, actualCy + outerR * sin];\n      const endPos = [actualCx + innerR * cos, actualCy + innerR * sin];\n      const getAxisXDomainLength = () => {\n        const {\n          domain\n        } = xScale.getOptions();\n        return domain.length;\n      };\n      const controllAngleCount = isPolar(coordinate) && xScale ? getAxisXDomainLength() : 3;\n      return {\n        startPos,\n        endPos,\n        gridClosed: Math.abs(endAngle - startAngle - 360) < 1e-6,\n        gridCenter: [actualCx, actualCy],\n        gridControlAngles: new Array(controllAngleCount).fill(0).map((d, i, arr) => (endAngle - startAngle) / controllAngleCount * i)\n      };\n    }\n  }\n  // position is inner or outer for arc axis won't be here\n  return {};\n}\nconst ArcAxisComponent = options => {\n  const {\n      order,\n      size,\n      position,\n      orientation,\n      labelFormatter,\n      tickFilter,\n      tickCount,\n      tickMethod,\n      important = {},\n      style = {},\n      indexBBox,\n      title,\n      grid = false\n    } = options,\n    rest = __rest(options, [\"order\", \"size\", \"position\", \"orientation\", \"labelFormatter\", \"tickFilter\", \"tickCount\", \"tickMethod\", \"important\", \"style\", \"indexBBox\", \"title\", \"grid\"]);\n  return _ref => {\n    let {\n      scales: [scale],\n      value,\n      coordinate,\n      theme\n    } = _ref;\n    const {\n      bbox\n    } = value;\n    const {\n      domain\n    } = scale.getOptions();\n    const data = getData(scale, domain, tickCount, labelFormatter, tickFilter, tickMethod, position, coordinate);\n    // Bind computed bbox if exists.\n    const labels = indexBBox ? data.map((d, i) => {\n      const bbox = indexBBox.get(i);\n      if (!bbox) return d;\n      // bbox: [label, bbox]\n      // Make than indexBBox can match current label.\n      if (bbox[0] !== d.label) return d;\n      return Object.assign(Object.assign({}, d), {\n        bbox: bbox[1]\n      });\n    }) : data;\n    const [innerRadius, outerRadius] = radiusOf(coordinate);\n    const defaultStyle = inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate);\n    const {\n      axis: axisTheme,\n      axisArc = {}\n    } = theme;\n    const finalStyle = adaptor(deepMix({}, axisTheme, axisArc, defaultStyle, Object.assign(Object.assign({\n      type: 'arc',\n      data: labels,\n      titleText: titleContent(title),\n      grid\n    }, rest), important)));\n    return new AxisComponent({\n      // @fixme transform is not valid for arcAxis.\n      // @ts-ignore\n      style: omit(finalStyle, ['transform'])\n    });\n  };\n};\nfunction inferThemeStyle(scale, coordinate, theme, direction, position, orientation) {\n  const baseStyle = theme.axis;\n  const positionStyle = ['top', 'right', 'bottom', 'left'].includes(position) ? theme[`axis${capitalizeFirst(position)}`] : theme.axisLinear;\n  const channel = scale.getOptions().name;\n  const channelStyle = theme[`axis${upperFirst(channel)}`] || {};\n  return Object.assign({}, baseStyle, positionStyle, channelStyle);\n}\nfunction inferDefaultStyle(scale, coordinate, theme, direction, position, orientation) {\n  const themeStyle = inferThemeStyle(scale, coordinate, theme, direction, position, orientation);\n  if (position === 'center') {\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, themeStyle), {\n      labelDirection: direction === 'right' ? 'negative' : 'positive'\n    }), direction === 'center' ? {\n      labelTransform: 'translate(50%,0)'\n    } : null), {\n      tickDirection: direction === 'right' ? 'negative' : 'positive',\n      labelSpacing: direction === 'center' ? 0 : 4,\n      titleSpacing: isVertical(orientation) ? 10 : 0,\n      tick: direction === 'center' ? false : undefined\n    });\n  }\n  return themeStyle;\n}\nconst LinearAxisComponent = options => {\n  const {\n      direction = 'left',\n      important = {},\n      labelFormatter,\n      order,\n      orientation,\n      actualPosition,\n      position,\n      size,\n      style = {},\n      title,\n      tickCount,\n      tickFilter,\n      tickMethod,\n      transform,\n      indexBBox\n    } = options,\n    userDefinitions = __rest(options, [\"direction\", \"important\", \"labelFormatter\", \"order\", \"orientation\", \"actualPosition\", \"position\", \"size\", \"style\", \"title\", \"tickCount\", \"tickFilter\", \"tickMethod\", \"transform\", \"indexBBox\"]);\n  return _ref2 => {\n    let {\n      scales,\n      value,\n      coordinate,\n      theme\n    } = _ref2;\n    const {\n      bbox\n    } = value;\n    const [scale] = scales;\n    const {\n      domain,\n      xScale\n    } = scale.getOptions();\n    const defaultStyle = inferDefaultStyle(scale, coordinate, theme, direction, position, orientation);\n    const internalAxisStyle = Object.assign(Object.assign(Object.assign({}, defaultStyle), style), userDefinitions);\n    const gridLength = inferGridLength(actualPosition || position, coordinate, options.plane);\n    const overrideStyle = inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale);\n    const threeDOverrideStyle = infer3DAxisLinearOverrideStyle(coordinate);\n    const data = getData(scale, domain, tickCount, labelFormatter, tickFilter, tickMethod, position, coordinate);\n    // Bind computed bbox if exists.\n    const labels = indexBBox ? data.map((d, i) => {\n      const bbox = indexBBox.get(i);\n      if (!bbox) return d;\n      // bbox: [label, bbox]\n      // Make than indexBBox can match current label.\n      if (bbox[0] !== d.label) return d;\n      return Object.assign(Object.assign({}, d), {\n        bbox: bbox[1]\n      });\n    }) : data;\n    const finalAxisStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, internalAxisStyle), {\n      type: 'linear',\n      data: labels,\n      crossSize: size,\n      titleText: titleContent(title),\n      labelOverlap: inferLabelOverlap(transform, internalAxisStyle),\n      grid: inferGrid(internalAxisStyle.grid, coordinate, scale),\n      gridLength,\n      // Always showLine, make title could align the end of axis.\n      line: true,\n      indexBBox\n    }), !internalAxisStyle.line ? {\n      lineOpacity: 0\n    } : null), overrideStyle), threeDOverrideStyle), important);\n    // For hide overlap, do not set crossSize.\n    const hasHide = finalAxisStyle.labelOverlap.find(d => d.type === 'hide');\n    if (hasHide) finalAxisStyle.crossSize = false;\n    return new AxisComponent({\n      className: 'axis',\n      style: adaptor(finalAxisStyle)\n    });\n  };\n};\nconst axisFactor = axis => {\n  return options => {\n    const {\n      labelFormatter: useDefinedLabelFormatter,\n      labelFilter: userDefinedLabelFilter = () => true\n    } = options;\n    return context => {\n      var _a;\n      const {\n        scales: [scale]\n      } = context;\n      const ticks = ((_a = scale.getTicks) === null || _a === void 0 ? void 0 : _a.call(scale)) || scale.getOptions().domain;\n      const labelFormatter = typeof useDefinedLabelFormatter === 'string' ? format(useDefinedLabelFormatter) : useDefinedLabelFormatter;\n      const labelFilter = (datum, index, array) => userDefinedLabelFilter(ticks[index], index, ticks);\n      const normalizedOptions = Object.assign(Object.assign({}, options), {\n        labelFormatter,\n        labelFilter,\n        scale\n      });\n      return axis(normalizedOptions)(context);\n    };\n  };\n};\nexport const LinearAxis = axisFactor(LinearAxisComponent);\nexport const ArcAxis = axisFactor(ArcAxisComponent);\nLinearAxis.props = {\n  defaultPosition: 'center',\n  defaultSize: 45,\n  defaultOrder: 0,\n  defaultCrossPadding: [12, 12],\n  defaultPadding: [12, 12]\n};\nArcAxis.props = {\n  defaultPosition: 'outer',\n  defaultOrientation: 'vertical',\n  defaultSize: 45,\n  defaultOrder: 0,\n  defaultCrossPadding: [12, 12],\n  defaultPadding: [12, 12]\n};","map":{"version":3,"names":["Axis","AxisComponent","Linear","LinearScale","deepMix","omit","upperFirst","extent","format","angleOf","isFisheye","isParallel","isPolar","isRadial","isTheta","isTranspose","radiusOf","prettyNumber","capitalizeFirst","adaptor","isVertical","titleContent","rotateAxis","axis","options","eulerAngles","origin","setOrigin","rotate","sizeOf","coordinate","innerWidth","innerHeight","depth","getOptions","createFisheye","position","width","height","tick","tickPoint","vector","map","v","x","domain","range","ticksOf","scale","tickMethod","getTicks","min","max","d","tickCount","createInset","insetTop","insetBottom","insetLeft","insetRight","start","end","size","i","getData","defaultTickFormatter","tickFilter","undefined","update","Object","assign","ticks","filteredTicks","filter","toString","Date","String","labelFormatter","_a","getFormatter","call","applyInset","applyFisheye","isHorizontal","includes","array","offset","getBandWidth","shouldReverse","_b","value","label","id","inferGridLength","plane","arguments","length","inferLabelOverlap","transform","style","labelAutoRotate","labelAutoHide","labelAutoEllipsis","labelAutoWrap","finalTransforms","addToTransforms","overlap","state","push","type","optionalAngles","minLength","wordWrapWidth","maxLines","recoveryWhenFail","inferArcStyle","bbox","innerRadius","outerRadius","y","center","radius","Math","startAngle","endAngle","w","h","r","common","gridLength","labelAlign","labelDirection","tickDirection","gridDirection","inferGrid","infer3DAxisLinearOverrideStyle","tickIsBillboard","lineIsBillboard","labelIsBillboard","titleIsBillboard","gridIsBillboard","inferAxisLinearOverrideStyle","orientation","xScale","startPos","endPos","cx","cy","getCenter","innerR","outerR","actualCx","actualCy","cos","sin","getAxisXDomainLength","controllAngleCount","gridClosed","abs","gridCenter","gridControlAngles","Array","fill","arr","ArcAxisComponent","order","important","indexBBox","title","grid","rest","__rest","_ref","scales","theme","data","labels","get","defaultStyle","axisTheme","axisArc","finalStyle","titleText","inferThemeStyle","direction","baseStyle","positionStyle","axisLinear","channel","name","channelStyle","inferDefaultStyle","themeStyle","labelTransform","labelSpacing","titleSpacing","LinearAxisComponent","actualPosition","userDefinitions","_ref2","internalAxisStyle","overrideStyle","threeDOverrideStyle","finalAxisStyle","crossSize","labelOverlap","line","lineOpacity","hasHide","find","className","axisFactor","useDefinedLabelFormatter","labelFilter","userDefinedLabelFilter","context","datum","index","normalizedOptions","LinearAxis","ArcAxis","props","defaultPosition","defaultSize","defaultOrder","defaultCrossPadding","defaultPadding","defaultOrientation"],"sources":["component/axis.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}