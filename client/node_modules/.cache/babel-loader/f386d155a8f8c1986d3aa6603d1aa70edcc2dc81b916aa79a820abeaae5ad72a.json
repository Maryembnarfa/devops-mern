{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { rollups } from '@antv/vendor/d3-array';\nimport { defined } from '../utils/helper';\nimport { useLibrary } from './library';\nimport { applyDefaults, applyDataTransform, extractColumns, flatEncode, inferChannelsType, maybeArrayField, maybeVisualChannel, addGuideToScale, maybeNonAnimate, normalizeTooltip, extractTooltip } from './transform';\nexport function initializeMark(partialMark, partialProps, context) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // Apply transform to mark to derive indices, data, encode, etc,.\n    const [I, transformedMark] = yield applyMarkTransform(partialMark, partialProps, context);\n    const {\n      encode,\n      scale,\n      data,\n      tooltip\n    } = transformedMark;\n    // Skip mark with non-tabular data. Do not skip empty\n    // data, they are useful for facet to display axes.\n    if (Array.isArray(data) === false) {\n      return null;\n    }\n    // Group non-independent channels with same prefix, such as x1, x2 => x.\n    // For independent channels, dot not group them, such as position1, position2.\n    const {\n      channels: channelDescriptors\n    } = partialProps;\n    const nameChannels = rollups(Object.entries(encode).filter(_ref => {\n      let [, value] = _ref;\n      return defined(value);\n    }), values => values.map(_ref2 => {\n      let [key, options] = _ref2;\n      return Object.assign({\n        name: key\n      }, options);\n    }), _ref3 => {\n      let [key] = _ref3;\n      var _a;\n      const prefix = (_a = /([^\\d]+)\\d*$/.exec(key)) === null || _a === void 0 ? void 0 : _a[1];\n      const descriptor = channelDescriptors.find(d => d.name === prefix);\n      if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.independent) return key;\n      return prefix;\n    });\n    // Check required channels and initialize scale options for each channel.\n    const channels = channelDescriptors.filter(descriptor => {\n      const {\n        name,\n        required\n      } = descriptor;\n      if (nameChannels.find(_ref4 => {\n        let [d] = _ref4;\n        return d === name;\n      })) return true;\n      if (required) throw new Error(`Missing encoding for channel: ${name}.`);\n      return false;\n    }).flatMap(descriptor => {\n      const {\n        name,\n        scale: scaleType,\n        scaleKey,\n        range,\n        quantitative,\n        ordinal\n      } = descriptor;\n      const valuesArray = nameChannels.filter(_ref5 => {\n        let [channel] = _ref5;\n        return channel.startsWith(name);\n      });\n      return valuesArray.map((_ref6, i) => {\n        let [channel, values] = _ref6;\n        const visual = values.some(d => d.visual);\n        const constant = values.some(d => d.constant);\n        const _a = scale[channel] || {},\n          {\n            independent = false,\n            // Use channel name as default scale key.\n            key = scaleKey || channel,\n            // Visual channel use identity scale.\n            type = constant ? 'constant' : visual ? 'identity' : scaleType\n          } = _a,\n          scaleOptions = __rest(_a, [\"independent\", \"key\", \"type\"]);\n        // For constant scale, infer range from data.\n        const isConstant = type === 'constant';\n        const finalRange = isConstant ? undefined : range;\n        return {\n          name: channel,\n          values,\n          // Generate a unique key for independent channel,\n          // which will not group with any other channels.\n          scaleKey: independent || isConstant ? Symbol('independent') : key,\n          scale: Object.assign(Object.assign({\n            type,\n            range: finalRange\n          }, scaleOptions), {\n            quantitative,\n            ordinal\n          })\n        };\n      });\n    });\n    return [transformedMark, Object.assign(Object.assign({}, partialProps), {\n      index: I,\n      channels,\n      tooltip\n    })];\n  });\n}\nexport function createColumnOf(library) {\n  const [useEncode] = useLibrary('encode', library);\n  return (data, encode) => {\n    if (encode === undefined) return null;\n    if (data === undefined) return null;\n    return Object.assign(Object.assign({}, encode), {\n      type: 'column',\n      value: useEncode(encode)(data),\n      field: fieldOf(encode)\n    });\n  };\n}\nfunction applyMarkTransform(mark, props, context) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      library\n    } = context;\n    const [useTransform] = useLibrary('transform', library);\n    const {\n      preInference = [],\n      postInference = []\n    } = props;\n    const {\n      transform = []\n    } = mark;\n    const transforms = [applyDefaults, applyDataTransform, flatEncode, inferChannelsType, maybeVisualChannel, extractColumns, maybeArrayField, maybeNonAnimate, addGuideToScale, normalizeTooltip, ...preInference.map(useTransform), ...transform.map(useTransform), ...postInference.map(useTransform), extractTooltip];\n    let index = [];\n    let transformedMark = mark;\n    for (const t of transforms) {\n      [index, transformedMark] = yield t(index, transformedMark, context);\n    }\n    return [index, transformedMark];\n  });\n}\nfunction fieldOf(encode) {\n  const {\n    type,\n    value\n  } = encode;\n  if (type === 'field' && typeof value === 'string') return value;\n  return null;\n}","map":{"version":3,"names":["rollups","defined","useLibrary","applyDefaults","applyDataTransform","extractColumns","flatEncode","inferChannelsType","maybeArrayField","maybeVisualChannel","addGuideToScale","maybeNonAnimate","normalizeTooltip","extractTooltip","initializeMark","partialMark","partialProps","context","I","transformedMark","applyMarkTransform","encode","scale","data","tooltip","Array","isArray","channels","channelDescriptors","nameChannels","Object","entries","filter","_ref","value","values","map","_ref2","key","options","assign","name","_ref3","prefix","_a","exec","descriptor","find","d","independent","required","_ref4","Error","flatMap","scaleType","scaleKey","range","quantitative","ordinal","valuesArray","_ref5","channel","startsWith","_ref6","i","visual","some","constant","type","scaleOptions","__rest","isConstant","finalRange","undefined","Symbol","index","createColumnOf","library","useEncode","field","fieldOf","mark","props","useTransform","preInference","postInference","transform","transforms","t"],"sources":["runtime/mark.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}