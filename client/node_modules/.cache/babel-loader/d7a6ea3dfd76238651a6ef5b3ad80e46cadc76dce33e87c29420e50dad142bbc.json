{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { createGroups } from './utils/order';\nimport { GroupN } from './groupN';\n/**\n * The Group transform group data by x and y channels, and aggregate.\n */\nexport const Group = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n      channels = ['x', 'y']\n    } = options,\n    rest = __rest(options, [\"channels\"]);\n  const groupBy = (I, mark) => createGroups(channels, I, mark);\n  return GroupN(Object.assign(Object.assign({}, rest), {\n    groupBy\n  }));\n};\nGroup.props = {};","map":{"version":3,"names":["createGroups","GroupN","Group","options","arguments","length","undefined","channels","rest","__rest","groupBy","I","mark","Object","assign","props"],"sources":["transform/group.ts"],"sourcesContent":[null],"mappings":";;;;;;;;AAEA,SAASA,YAAY,QAAQ,eAAe;AAC5C,SAASC,MAAM,QAAQ,UAAU;AAcjC;;;AAGA,OAAO,MAAMC,KAAK,GAAqB,SAAAA,CAAA,EAAiB;EAAA,IAAhBC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EAClD,MAAM;MAAEG,QAAQ,GAAG,CAAC,GAAG,EAAE,GAAG;IAAC,IAAcJ,OAAO;IAAhBK,IAAI,GAAAC,MAAA,CAAKN,OAAO,EAA5C,YAAkC,CAAU;EAClD,MAAMO,OAAO,GAAGA,CAACC,CAAC,EAAEC,IAAI,KAAKZ,YAAY,CAACO,QAAQ,EAAEI,CAAC,EAAEC,IAAI,CAAC;EAC5D,OAAOX,MAAM,CAAAY,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAMN,IAAI;IAAEE;EAAO,GAAG;AACrC,CAAC;AAEDR,KAAK,CAACa,KAAK,GAAG,EAAE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}